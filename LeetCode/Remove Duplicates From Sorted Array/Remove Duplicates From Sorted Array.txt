[0,0,1,1,1,2,2,3,3,4]
 0 1 2 3 4 5 6 7 8 9

if index 0 == index 1:
	remove index 1
if index 0 == index 2:
	remove index 2:

if index 0 == index 3:
	remove index 3

......................

if index 0 == index 9:
	remove index 9



then

if index 1 == index 2:
	remove index 2:
if index 1 == index 3:
	remove index 3:
if index 1 == index 4:
	remove index 4:
.......................

if index 1 == index 9:
	remove index 9



***TEST***

[0,0,1,1,1,2,2,3,3,4]
 0 1 2 3 4 5 6 7 8 9

remove index 1 because it is the same as index 0\

[0,1,1,1,2,2,3,3,4]
 0 1 2 3 4 5 6 7 8

*** so its obvious now that the "Index out of bounds error occurs because after popping an element from the
list, the length of the list is n-1. After the for loop is initialized the len value is not calculated again
to accomodate for the change in length

this means that if the original length of the array is 10 and you pop 3 elements, the loop will still run
10 times unless other wise stopped. If it is not stopped it will lead to an "index out of bounds error".

option 1: use and if statement to check if the values are still within bounds

option 2: make a copy of the nums array and compare values and delete values in the array that way


___either way, we need to know how long to runn the loops____

1. My first thought naturally is to run the loop for the length of the array. Meaning if the array is 10
indexes long, we loop ten times. The problem is, even if we get rid of one element. Then we cant run 10 times
without and index out of bounds error. Also the time complexity is O(n^2) which is terrible.

**** i just noticed something. the output will be accepted if i dont pop but rather replace the duplicates
in the list with spaces. I need to read the directions more thouroughly, so that I have the whole picture,
sometimes theres also clues and stuff.***

2. Second thought, instead of popping from list. I will replace duplicates with a space. That way I avoid any
index out of bounds errors.


*** one of the test cases uses an array of length 2 so because you are wrtiing in the "solutions" class,
you can hard code or iterater over anything manually without and index out of bounds error"




___Things I need to look up after___
how do the ranges work for for loops
how does .pop() work?
how to handle i+1 cases when at the bounds of the iterable
when do we do length of list - 1 again?? its been a minute

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        for i in range(len(nums)): # 0 - list-length - 1 (if len = 10 then 0-9 are the indices)
            for j in range(1, len(nums)): # check current index with the other indices
                if i+j < len(nums)-1 and nums[i] == nums[i+j]:
                    nums.pop([i+j])





We are not that far off from the solution, dont give up.

I have written enough to identify which indices need to be removed.
The problem is if i use pop, it shrinks the array and shifts everything down in a way that messes stuff up


I think next time i need to think about the problem more befor just going with a for loop.
asking my self "ok, what type of data structure, algorithim or iterating function would work best here?





Popping


[0,1,1,1,2,2,3,3,4]
 0 1 2 3 4 5 6 7 8

remove the all duplicates of 1

[0,1,2,2,3,3,4]
 0 1 2 3 4 5 6

every thing after the popped index gets shifted down
the length of the list is decreased by 1



        out = []
        for i in range(len(nums)):
            if nums[i] != 9:
                out.append(nums[i])
        print(out)

        nums.clear()
        for i in range(len(out)):
            nums.append(out[i])


so I was able to cheese it and passs 360/362 test but now im exceeding the time limit which is good
because it gives me a reason to upgrade what I have into an actual proper solution.

 class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        for i in range(len(nums)): # 0 - list-length - 1 (if len = 10 then 0-9 are the indices)
            for j in range(1, len(nums)+1): # check current index with the other indices
                if i+j < len(nums) and nums[i] == nums[i+j]:
                    nums[i+j] = 7489237492347238


        out = []
        for i in range(len(nums)):
            if nums[i] != 7489237492347238:
                out.append(nums[i])
        print(out)

        nums.clear()
        for i in range(len(out)):
            nums.append(out[i])


1. State the problem clearly




